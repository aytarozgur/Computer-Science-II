# Chapter 1 (Pages  1 - 19)  
  
---------------------------------------------------------------------------


## Section 1.2 - Fundamentals of Problem Solving

---------------------------------------------------------------------------

###  1. Understanding the Problem
- An input to an Algorithm specified an **instance** of the problem the algorithm solves.  

---------------------------------------------------------------------------
###  2. Ascertain the Capabilities of the Computational Device
- **Random-Access Machine** - Computer system which executes instructions one after the other, sequentially.
- **Sequential Algorithms** - Algorithms designed to execute each statement sequentially.
- **Parallel Algorithms** - Algorithms designed for parallel execution of statements.

---------------------------------------------------------------------------
### 3. Choose between Exact solution and Approximate solution
- Evaluation of a definite integral would need an approximate solution while finding the Greatest-Common Divisor requires an exact solution.

---------------------------------------------------------------------------
### 4. Algorithm Design Techniques
- **Algorithm Design Technique** - A general approach to solving problems algorithmically applicable to a variety of problems from different areas of computing.

---------------------------------------------------------------------------
### 5. Designing Algorithms and Data Structures
- Practicing Algorithm Design makes future projects easier to tackle
- Choosing the appropriate data structure is important
  - *Sieve of Erathosthene*   
    - Using an array is more efficient than using a linked list.
    
---------------------------------------------------------------------------
### 6. Methods of specifying Algorithms
- Options:
  1. *Natural Language* 
    - Not practical and confusing
  2. *Pseudocode* 
    - There is no standard defined for writing pseudocode 
  3. *Flowchart*
    - Found to be inconvenient for complex algorithms
    
    
---------------------------------------------------------------------------
### 7. Proving Correctness
- **Mathematical Induction** is a common technique used to prove correctness
- Proving the correctness of an approximate algorithm is less straighforward than it is for exact algorithms.

---------------------------------------------------------------------------
### 8. Analysis 
- Characteristics
  - Efficiency 
    - Time Efficiency - Indicates how fast an algorithm runs.
    - Space Efficiency - Indicates how much memeory is used.  
  - Simplicity
  - Generality
  